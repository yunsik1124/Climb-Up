<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
    <title>Climb-Up — Labeled & Safe Start</title>
    <style>
        :root {
            --bg: #0b0f14;
            --fg: #e8f0ff;
            --accent: #46d3ff;
            --danger: #ff6b6b;
            --ok: #67ff9a;
            --buff: #ffd447;
            --lock: #8888ff;
            --key: #ffff66;
            --wall: #333;
            --win: #555;
            --platform: #8aa0bd;
            --safe: #46d3ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html, body {
            height: 100%;
            width: 100%;
            background: var(--bg);
            color: var(--fg);
            font-family: system-ui,Apple SD Gothic Neo,Roboto,Arial;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            touch-action: none;
            background: url('images/bg.png') no-repeat center center;
            background-size: cover;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: var(--fg);
            text-shadow: 0 1px 2px #000;
        }

        #gameover {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: rgba(0,0,0,.85);
            color: #fff;
            padding: 20px 24px;
            border-radius: 14px;
            width: min(92vw,420px);
            text-align: center;
            display: none
        }

            #gameover button {
                margin-top: 12px;
                background: var(--accent);
                border: 0;
                color: #001625;
                padding: 10px 16px;
                border-radius: 10px;
                font-weight: 700;
                cursor: pointer
            }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="ui">높이: <span id="score">0</span></div>
    <div id="gameover">
        <h2 style="margin:0 0 6px">게임 오버!</h2>
        <p style="margin:0 0 8px">최종 높이: <span id="finalScore">0</span></p>
        <button onclick="restart()">다시 시작</button>
    </div>

    <script>
        /* ========= 기본 설정 & 캔버스 비율(9:16) ========= */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        function resizeCanvas() {
            const ratio = 9 / 16;
            let w = innerWidth, h = innerHeight;
            if (w / h > ratio) { h = innerHeight; w = h * ratio; } else { w = innerWidth; h = w / ratio; }
            canvas.width = w; canvas.height = h;
        }
        addEventListener('resize', resizeCanvas);
        resizeCanvas();

        /* ========= 게임 상태 ========= */
        let gravity = 0.3;
        let jumpPower = -12;
        let score = 0;
        let gameOver = false;
        let jumpPressed = false;

        const WALL_THICK = 20;
        const WORLD_LEFT = () => 0 + WALL_THICK;
        const WORLD_RIGHT = () => canvas.width - WALL_THICK;

        /* ========= 플레이어 ========= */
        const player = {
            x: 0, y: 0, w: 36, h: 48,
            vx: 0, vy: 0,
            onGround: false, hasKey: false,
            animTime: 0, state: 'idle', // 'idle' | 'run' | 'jump' | 'land'
            landTimer: 0
        };

        /* ========= 컨텐츠 컨테이너 ========= */
        let floors = [];       // 플랫폼 (기본/사라짐/이동/버프/엘베/시작바닥)
        let obstacles = [];    // 가시/지뢰
        let winds = [];        // 바람 구간
        let locks = [];        // 자물쇠 문
        let keysItem = [];     // 열쇠
        let windows = [];      // 배경 창문
        let particles = [];    // 폭발/바람 파티클
        let corridors = [];    // 좁은 통로 섹션(좌우 벽 닫힘)

        /* ========= 생성기 ========= */
        const floorGap = 120;
        const floorCount = 22;

        function rand(min, max) { return Math.random() * (max - min) + min; }

        function createFloor(y) {
            const width = rand(80, 260);
            const x = rand(WORLD_LEFT(), WORLD_RIGHT() - width);
            // 기믹 확률
            const r = Math.random();
            let gimmick = null;
            if (r < 0.12) gimmick = 'vanish';
            else if (r < 0.26) gimmick = 'move';      // 좌우 이동
            else if (r < 0.36) gimmick = 'buff';      // 점프 강화
            else if (r < 0.43) gimmick = 'elevator';  // 상하 이동
            return { x, y, w: width, h: 16, gimmick, dir: 1, vanishTimer: 0, vy: 0 };
        }

        function createBaseFloor() {
            // 시작 바닥: 안전, 빈틈 없음, 화면 하단을 가로지르는 발판
            return { x: WORLD_LEFT(), y: canvas.height - 24, w: WORLD_RIGHT() - WORLD_LEFT(), h: 24, gimmick: 'base', dir: 0, vanishTimer: 0, vy: 0 };
        }

        function createSpike(y) {
            const x = rand(WORLD_LEFT() + 10, WORLD_RIGHT() - 40);
            return { x, y, w: 30, h: 28, type: 'spike' };
        }

        function createMine(y) {
            const x = rand(WORLD_LEFT() + 10, WORLD_RIGHT() - 40);
            return { x, y, w: 28, h: 20, type: 'mine', exploding: false };
        }

        function createWind(y) {
            return { y, h: 200, dir: Math.random() < 0.5 ? -1 : 1, strength: 0.45, t: 0 };
        }

        function createLock(y) {
            return { x: canvas.width / 2 - 52, y, w: 104, h: 22, locked: true };
        }

        function createKey(y) {
            const x = rand(WORLD_LEFT() + 10, WORLD_RIGHT() - 30);
            return { x, y, w: 20, h: 20 };
        }

        function createCorridor(y) {
            // 좁은 통로: 좌/우에서 벽이 들어와 gap만 통과 가능
            const gapW = rand(80, 140);
            const gapX = rand(WORLD_LEFT() + 10, WORLD_RIGHT() - gapW - 10);
            return { y, h: 200, gapX, gapW };
        }

        function createWindows() {
            windows = [];
            for (let i = 0; i < 56; i++) {
                windows.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height * 2, w: 18, h: 18 });
            }
        }

        /* ========= 입력 ========= */
        const keys = {};
        addEventListener('keydown', e => keys[e.key] = true);
        addEventListener('keyup', e => { keys[e.key] = false; if (e.key === 'z' || e.key === 'x') jumpPressed = false; });

        let touchLeft = false, touchRight = false, touchJump = false;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            if (x < canvas.width / 3) touchLeft = true;
            else if (x > canvas.width * 2 / 3) touchRight = true;
            else touchJump = true;
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            touchLeft = false; touchRight = false; touchJump = false;
            jumpPressed = false;
        });

        /* ========= 초기화 ========= */
        function init() {
            score = 0; gameOver = false; jumpPressed = false;
            floors = []; obstacles = []; winds = []; locks = []; keysItem = []; particles = []; corridors = [];
            createWindows();

            // 안전한 시작 바닥 + 위쪽으로 일반 층들
            const base = createBaseFloor();
            floors.push(base);
            for (let i = 1; i < floorCount; i++) {
                floors.push(createFloor(canvas.height - i * floorGap));
            }

            // 시작 위치: 안전 바닥 위 중앙
            const start = base;
            player.x = start.x + start.w / 2 - player.w / 2;
            player.y = start.y - player.h;
            player.vx = 0; player.vy = 0; player.hasKey = false;
            player.state = 'idle'; player.animTime = 0; player.landTimer = 0;
        }
        init();

        /* ========= 유틸: 파티클 ========= */
        function spawnExplosion(x, y, count = 22) {
            for (let i = 0; i < count; i++) {
                const ang = Math.random() * Math.PI * 2;
                const spd = rand(1.5, 4.2);
                particles.push({
                    x, y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd - 1,
                    life: rand(28, 42), t: 0, color: i % 3 ? '#ffcf66' : '#ff725c', size: rand(2, 4)
                });
            }
        }

        /* ========= 충돌 헬퍼 ========= */
        function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
            return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
        }

        /* ========= 보조 그리기 ========= */
        function getCss(v) { return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
        function roundRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();
        }
        function drawKeyIcon(x, y, w, h) {
            ctx.fillRect(x, y + h * 0.4, w * 0.65, h * 0.2);
            ctx.beginPath();
            ctx.arc(x + w * 0.75, y + h * 0.5, h * 0.28, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawTag(cx, y, text, kind) {
            // kind: '장애물' | '도움' | '발판' | '안전'
            let color = '#ddd';
            if (kind === '장애물') color = getCss('--danger');
            else if (kind === '도움') color = getCss('--ok');
            else if (kind === '발판') color = getCss('--platform');
            else if (kind === '안전') color = getCss('--safe');

            ctx.font = '12px system-ui, Apple SD Gothic Neo, Arial';
            const padX = 6, padY = 4;
            const tw = ctx.measureText(text).width;
            const bx = cx - tw / 2 - padX, by = y - 18;
            ctx.fillStyle = 'rgba(0,0,0,.65)';
            roundRect(bx, by, tw + padX * 2, 16 + padY * 0, 6);
            ctx.fillStyle = color;
            ctx.fillText(text, bx + padX, by + 12);
        }

        /* ========= 플레이어 그리기(애니메이션) ========= */
        function drawPlayer() {
            if (!player.onGround) player.state = 'jump';
            else if (Math.abs(player.vx) > 0.1) player.state = 'run';
            else player.state = 'idle';

            player.animTime += 0.16;

            let sx = 1, sy = 1;
            if (player.state === 'jump') { sy = 0.92; sx = 1.06; }
            if (player.state === 'land' && player.landTimer > 0) {
                const k = Math.min(1, player.landTimer / 8);
                sy = 1 + 0.15 * k; sx = 1 - 0.1 * k;
                player.landTimer--;
            }

            const legSwing = Math.sin(player.animTime * 8) * 6;
            const px = player.x + player.w / 2;
            const py = player.y + player.h / 2;

            ctx.save();
            ctx.translate(px, py);
            ctx.scale(sx, sy);

            // 그림자
            ctx.fillStyle = 'rgba(0,0,0,.25)';
            ctx.beginPath(); ctx.ellipse(0, player.h / 2, player.w * 0.45, 6, 0, 0, Math.PI * 2); ctx.fill();

            // 몸통
            ctx.fillStyle = '#38e0ff';
            ctx.fillRect(-player.w / 2, -player.h / 2 + 6, player.w, player.h - 8);

            // 머리
            ctx.fillStyle = '#0aa0ff';
            ctx.fillRect(-player.w / 2, -player.h / 2, player.w, 16);

            // 눈
            ctx.fillStyle = '#001b2a';
            ctx.fillRect(-player.w / 4, -player.h / 2 + 4, 6, 6);
            ctx.fillRect(player.w / 4 - 6, -player.h / 2 + 4, 6, 6);

            // 다리
            function leg(xoff, angle) {
                ctx.save(); ctx.translate(xoff, player.h / 2 - 10); ctx.rotate(angle * Math.PI / 180);
                ctx.fillStyle = '#004a7a'; ctx.fillRect(-4, 0, 8, 16); ctx.restore();
            }
            if (player.state === 'run') { leg(-7, -legSwing); leg(7, legSwing); }
            else { leg(-7, 0); leg(7, 0); }

            ctx.restore();
        }

        /* ========= 메인 루프 ========= */
        function loop() {
            if (gameOver) return;

            /* 배경 & 벽 & 창문 */
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getCss('--wall');
            ctx.fillRect(0, 0, WALL_THICK, canvas.height);
            ctx.fillRect(canvas.width - WALL_THICK, 0, WALL_THICK, canvas.height);

            ctx.fillStyle = getCss('--win');
            for (const w of windows) {
                ctx.fillRect(w.x, w.y + (score % canvas.height), w.w, w.h);
            }

            /* 입력 */
            const movingLeft = keys['ArrowLeft'] || touchLeft;
            const movingRight = keys['ArrowRight'] || touchRight;
            if (movingLeft) player.vx = -5;
            else if (movingRight) player.vx = 5;
            else player.vx = 0;

            if ((keys['z'] || keys['x'] || touchJump) && player.onGround && !jumpPressed) {
                player.vy = jumpPower;
                player.onGround = false;
                jumpPressed = true;
            }

            /* 물리 */
            player.vy += gravity;
            player.x += player.vx;
            player.y += player.vy;

            // 좌/우 벽 충돌
            if (player.x < WORLD_LEFT()) player.x = WORLD_LEFT();
            if (player.x + player.w > WORLD_RIGHT()) player.x = WORLD_RIGHT() - player.w;

            /* 바람 영향 + 라벨 */
            for (const w of winds) {
                w.t += 0.02;
                // 시각 효과
                ctx.save();
                ctx.globalAlpha = 0.08;
                ctx.fillStyle = '#8fd7ff';
                for (let i = 0; i < 12; i++) {
                    const yy = w.y + (i / 12) * w.h + ((w.t * 80 + i * 12) % 16);
                    ctx.fillRect(w.dir < 0 ? WORLD_LEFT() : WORLD_RIGHT() - 120, yy, 120, 2);
                }
                ctx.restore();

                // 라벨
                drawTag((WORLD_LEFT() + WORLD_RIGHT()) / 2, w.y + 10, '바람(장애물)', '장애물');

                // 힘 적용
                if (player.y + player.h > w.y && player.y < w.y + w.h) {
                    player.x += w.dir * w.strength * 10;
                }
            }

            /* 좁은 통로 + 라벨 */
            ctx.fillStyle = '#2b2b2b';
            for (const c of corridors) {
                // 좌우 벽
                ctx.fillRect(WORLD_LEFT(), c.y, c.gapX - WORLD_LEFT(), c.h);
                const rightWallX = c.gapX + c.gapW;
                ctx.fillRect(rightWallX, c.y, WORLD_RIGHT() - rightWallX, c.h);

                drawTag(c.gapX + c.gapW / 2, c.y + 16, '좁은 통로(장애물)', '장애물');

                // 플레이어 보정
                if (player.y + player.h > c.y && player.y < c.y + c.h) {
                    if (player.x < c.gapX) player.x = c.gapX;
                    if (player.x + player.w > c.gapX + c.gapW) player.x = c.gapX + c.gapW - player.w;
                }
            }

            /* 발판(충돌 포함) + 라벨 */
            let wasGround = player.onGround;
            player.onGround = false;

            for (const f of floors) {
                // 기믹 이동
                if (f.gimmick === 'move') {
                    f.x += f.dir * 1.6;
                    if (f.x < WORLD_LEFT() || f.x + f.w > WORLD_RIGHT()) f.dir *= -1;
                }
                if (f.gimmick === 'elevator') {
                    f.vy = f.dir * 1.2;
                    f.y += f.vy;
                    if (f.y < 40 || f.y > canvas.height - 30) f.dir *= -1;
                } else {
                    f.vy = 0;
                }

                // 그리기
                if (f.gimmick === 'vanish') ctx.fillStyle = getCss('--danger');
                else if (f.gimmick === 'move') ctx.fillStyle = 'orange';
                else if (f.gimmick === 'buff') ctx.fillStyle = getCss('--buff');
                else if (f.gimmick === 'elevator') ctx.fillStyle = '#7dd3a5';
                else if (f.gimmick === 'base') ctx.fillStyle = '#66a2ff';
                else ctx.fillStyle = '#fff';
                roundRect(f.x, f.y, f.w, f.h, 4);

                // 라벨 텍스트
                let label = '', kind = '발판';
                if (f.gimmick === 'vanish') { label = '사라지는 발판(장애물)'; kind = '장애물'; }
                else if (f.gimmick === 'move') { label = '이동 발판(발판)'; kind = '발판'; }
                else if (f.gimmick === 'buff') { label = '점프 버프(도움)'; kind = '도움'; }
                else if (f.gimmick === 'elevator') { label = '엘리베이터(발판)'; kind = '발판'; }
                else if (f.gimmick === 'base') { label = '시작 바닥(발판)'; kind = '안전'; }
                else { label = '발판(기본)'; kind = '발판'; }

                drawTag(f.x + f.w / 2, f.y - 2, label, kind);

                // 충돌(관통 방지 여유)
                if (player.vy >= 0 &&
                    player.x < f.x + f.w && player.x + player.w > f.x &&
                    player.y + player.h > f.y - 6 && player.y + player.h < f.y + 10) {
                    if (f.gimmick === 'vanish') {
                        // 시작 바닥은 사라지지 않음
                        if (f.gimmick === 'vanish') {
                            f.vanishTimer++;
                            if (f.vanishTimer < 28) {
                                landOn(f);
                            }
                        }
                    } else if (f.gimmick === 'buff') {
                        landOn(f); player.vy = jumpPower * 1.55; player.onGround = false;
                    } else {
                        landOn(f);
                    }
                }
            }
            if (player.onGround && !wasGround) { player.state = 'land'; player.landTimer = 10; }

            function landOn(f) {
                player.y = f.y - player.h;
                player.vy = 0;
                player.onGround = true;
            }

            /* 방해물 + 라벨 */
            for (const o of obstacles) {
                if (o.type === 'spike') {
                    ctx.fillStyle = '#ff5454';
                    ctx.beginPath();
                    ctx.moveTo(o.x, o.y + o.h);
                    ctx.lineTo(o.x + o.w / 2, o.y);
                    ctx.lineTo(o.x + o.w, o.y + o.h);
                    ctx.closePath();
                    ctx.fill();
                    drawTag(o.x + o.w / 2, o.y - 2, '가시(장애물)', '장애물');
                    if (aabb(player.x, player.y, player.w, player.h, o.x, o.y, o.w, o.h)) endGame();
                } else if (o.type === 'mine') {
                    ctx.fillStyle = o.exploding ? '#ffa552' : '#999';
                    roundRect(o.x, o.y, o.w, o.h, 4);
                    drawTag(o.x + o.w / 2, o.y - 2, '지뢰(장애물)', '장애물');
                    if (!o.exploding && aabb(player.x, player.y, player.w, player.h, o.x, o.y, o.w, o.h)) {
                        o.exploding = true; spawnExplosion(o.x + o.w / 2, o.y + o.h / 2, 28); setTimeout(endGame, 480);
                    }
                }
            }

            /* 열쇠 & 자물쇠 + 라벨 */
            for (let i = keysItem.length - 1; i >= 0; i--) {
                const k = keysItem[i];
                ctx.fillStyle = getCss('--key');
                drawKeyIcon(k.x, k.y, k.w, k.w);
                drawTag(k.x + k.w / 2, k.y - 2, '열쇠(도움)', '도움');
                if (aabb(player.x, player.y, player.w, player.h, k.x, k.y, k.w, k.w)) { player.hasKey = true; keysItem.splice(i, 1); }
            }
            for (const l of locks) {
                ctx.fillStyle = l.locked ? getCss('--lock') : '#44ff66';
                roundRect(l.x, l.y, l.w, l.h, 6);
                drawTag(l.x + l.w / 2, l.y - 2, l.locked ? '자물쇠 문(장애물)' : '열린 문(발판)', l.locked ? '장애물' : '발판');
                if (aabb(player.x, player.y, player.w, player.h, l.x, l.y, l.w, l.h)) {
                    if (l.locked && !player.hasKey) endGame(); else l.locked = false;
                }
            }

            /* 플레이어 그리기 */
            drawPlayer();

            /* 파티클 */
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.t++; p.x += p.vx; p.y += p.vy; p.vy += 0.08;
                const alpha = Math.max(0, 1 - p.t / p.life);
                ctx.globalAlpha = alpha; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1;
                if (p.t > p.life) particles.splice(i, 1);
            }

            /* 스크롤(무한 위로) */
            if (player.y < canvas.height / 2) {
                const dy = (canvas.height / 2 - player.y);
                player.y += dy;

                for (const f of floors) f.y += dy;
                for (const o of obstacles) o.y += dy;
                for (const w of winds) w.y += dy;
                for (const l of locks) l.y += dy;
                for (const k of keysItem) k.y += dy;
                for (const c of corridors) c.y += dy;
                for (const win of windows) win.y += dy * 0.5;
                for (const p of particles) p.y += dy * 0.2;

                score += Math.floor(dy / 9);

                // 위쪽 채우기
                while (floors.length < floorCount) {
                    const topY = Math.min(...floors.map(fl => fl.y));
                    floors.push(createFloor(topY - floorGap));
                    if (Math.random() < 0.10) obstacles.push(createSpike(topY - 58));
                    if (Math.random() < 0.06) obstacles.push(createMine(topY - 82));
                    if (Math.random() < 0.06) winds.push(createWind(topY - 220));
                    if (Math.random() < 0.05) locks.push(createLock(topY - 44));
                    if (Math.random() < 0.05) keysItem.push(createKey(topY - 100));
                    if (Math.random() < 0.06) corridors.push(createCorridor(topY - 180));
                }

                // 아래쪽 정리(시작 바닥은 남겨둠)
                const keepBase = floors.find(fl => fl.gimmick === 'base');
                floors = floors.filter(fl => fl === keepBase || fl.y < canvas.height + 60);
                obstacles = obstacles.filter(o => o.y < canvas.height + 80);
                winds = winds.filter(w => w.y < canvas.height + 320);
                locks = locks.filter(l => l.y < canvas.height + 80);
                keysItem = keysItem.filter(k => k.y < canvas.height + 80);
                corridors = corridors.filter(c => c.y < canvas.height + 260);
            }

            // 아래로 추락하면 게임오버 (시작 바닥에서는 안전하지만, 이후 높이에서 낙하 시 사망)
            if (player.y > canvas.height + 120) endGame();

            // 점수
            document.getElementById('score').textContent = score;

            requestAnimationFrame(loop);
        }
        loop();

        /* ========= 종료/재시작 ========= */
        function endGame() {
            if (gameOver) return;
            gameOver = true;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameover').style.display = 'block';
        }
        function restart() {
            document.getElementById('gameover').style.display = 'none';
            init();
            loop();
        }
    </script>
</body>
</html>